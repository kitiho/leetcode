# 二分查找

## 例题

给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。

![image-20220920164629474](/Users/duanjipeng/Library/Application Support/typora-user-images/image-20220920164629474.png)

提示：

- 你可以假设 nums 中的所有元素是不重复的。
- n 将在 [1, 10000]之间。
- nums 的每个元素都将在 [-9999, 9999]之间。

## 思路

这道题的前提是数组为有序数组，同时数组中无重复元素，因为一旦有重复元素，使用二分查找法返回的元素下标可能不是唯一的。这些都是使用二分的前提条件，当看到题目描述满足如上条件的时候，就要考虑考虑二分法了。

二分查找涉及的很多边界条件，逻辑比较简单，但就是写不好。主要是因为**对区间的定义没有想清楚，区间的定义就是不变量**。要在二分查找的过程中，保持不变量，就是在while寻找中每一次边界的处理都要坚持根据区间的定义来操作，这就是**循环不变量**规则。

写二分法，区间的定义一般为两种，左闭右闭[left, right]，或者左闭右开[left, right)。

下面用这两种区间的定义分别讲解两种不同的二分法。

### 第一种

我们定义target是在一个左闭右闭的区间里，[left, right]中。

区间的定义就决定了二分法的代码应该如何写，因为定义target在[left, right]区间，所以有：

- `while (left <= right)` 要使用`<=`，因为left === right 是有意义的，所以使用`<=`
- `if(nums[middle] > target)`right要赋值为middle - 1，因为当前这个nums[middle]一定不是target，那么接下来要查找的左区间结束下标位置就是middle - 1

例如在数组[1,2,3,4,7,9,10]中查找2，如图：

![image-20220920165438460](/Users/duanjipeng/Library/Application Support/typora-user-images/image-20220920165438460.png)

代码如下：

```js
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number}
 */
var search = function (nums, target) {
    const len = nums.length
    let left = 0
    let right = len - 1
    while (left <= right) {
        let mid = left + ((right - left) >> 1)
        if (nums[mid] < target) {
            left = mid + 1
        }
        else if (nums[mid] > target) {
            right = mid - 1
        } else {
            return mid
        }
    }
    return -1
};
```

### 第二种写法

如果说定义target在一个左闭右开的区间里，[left, right)，那么二分法的边界处理方式截然不同，有如下两点：

- `while (left < right)`，这里使用<，是因为left === right在区间[left, right)是没有意义的。
- `if(nums[middle] > target)`，right要更新为middle，因为当前nums[middle]不等于target，去左区间继续寻找，而寻找区间是左闭右开的，所以right更新为middle。

在数组[1,2,3,4,7,9,10]寻找2，如图，注意与方法一的区别：

![image-20220920170451618](/Users/duanjipeng/Library/Application Support/typora-user-images/image-20220920170451618.png)

代码如下：

```js
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number}
 */
var search = function (nums, target) {
    const len = nums.length
    let left = 0
     // 在[left,right) 所以right是len开始
    let right = len
    while (left < right) {
        let mid = left + ((right - left) >> 1)
        if (nums[mid] < target) {
            // target在右边，那就在 [middle + 1 , right)
            left = mid + 1
        }
        else if (nums[mid] > target) {
            // target在左边，那就在 [left , middle)
            right = mid
        } else {
            return mid
        }
    }
    return -1
};
```
## 总结
二分法是非常重要的基础算法，主要是要理解清楚区间的定义，在循环中始终坚持根据查找区间的定义来做边界处理。
区间的定义就是不变量，循环不变量规则。

## 相关题目推荐
- 35.搜索插入位置(opens new window)
- 34.在排序数组中查找元素的第一个和最后一个位置(opens new window)
- 69.x 的平方根
- 367.有效的完全平方数
